using System.Collections;
using System.Collections.Generic;
using UnityEngine;
//对象池管理
public class PoolsManager : MonoBehaviour
{   //某一种零件需要索引的位置
    public int[] currentIndex = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0 };
    public Transform poolHome;
    public static PoolsManager instance;//单例模式主要用在对象池方面的调用，减少重复的实例化
    public Dictionary<int, List<GameObject>> pools = new Dictionary<int, List<GameObject>>();//字典的索引类型，存储不同类型模型，
    private bool lockPool = false;
    private int num = 0;

    void Start()
    {
        instance = this;
    }

    public GameObject Create(int key, GameObject prefab, Vector3 position, Quaternion qua, Vector3 length)
    {
        GameObject Component;
        if (pools.ContainsKey(key))
        {
            for (int i = 0; i < pools[key].Count; ++i)   //把对象池遍历一遍
            {
                if (!pools[key][i].activeInHierarchy) //判断该对象是否在场景中激活。
                {
                    currentIndex[key]--;
                    Component = pools[key][i];
                    Component.SetActive(true); //找到没有被激活的对象激活
                    Component.transform.position = position;
                    Component.transform.rotation = qua;
                    Component.transform.localScale = length;
                    return Component;
                }
            }

            //如果遍历完一遍对象库发现没有可以用的，执行下面生成一个新的并加到字典类型里
            if (!lockPool)                               //如果没有锁定对象池大小，创建对象并添加到对象池中。
            {
                Component = Instantiate(prefab, position, qua, poolHome);
                //Component.transform.parent = poolHome;
                Component.transform.localScale = length;
                Component.name = Component.name + num;
                num++;
                pools[key].Add(Component);
                return Component;
            }
            else
                return null;
        }
        //如果没有生成任何物体，则不需要遍历，直接加键值来储存物体
        else
        {
            pools.Add(key, new List<GameObject>());
            Component = Instantiate(prefab, position, qua, poolHome);//通过调用直接实例化
            //Component.transform.parent = poolHome;
            Component.transform.localScale = length;
            Component.name = Component.name + num;
            num++;
            currentIndex[key] = 0;
            pools[key].Add(Component);
            return Component;
        }
    }


    public GameObject CreateCopy(int key, GameObject prefab, Vector3 position, Quaternion qua, Vector3 length)
    {
        GameObject Component;
        if (pools.ContainsKey(key))
        {
            for (int i = 0; i < pools[key].Count; ++i)   //把对象池遍历一遍
            {
                if (!pools[key][i].activeInHierarchy) //判断该对象是否在场景中激活。
                {
                    currentIndex[key]--;
                    Component = pools[key][i];
                    Component.SetActive(true); //找到没有被激活的对象激活
                    Component.transform.position = position;
                    Component.transform.rotation = qua;
                    Component.transform.localScale = length;
                    return Component;
                }
            }

            //如果遍历完一遍对象库发现没有可以用的，执行下面
            if (!lockPool)                               //如果没有锁定对象池大小，创建对象并添加到对象池中。
            {
                Component = Instantiate(prefab, position, qua, poolHome);
                //Component.transform.parent = poolHome;
                Component.transform.localScale = length;
                Component.name = Component.name + num;
                num++;
                pools[key].Add(Component);
                return Component;
            }
            else
                return null;
        }
        else
        {
            pools.Add(key, new List<GameObject>());
            Component = Instantiate(prefab, position, qua, poolHome);
            //Component.transform.parent = poolHome;
            Component.transform.localScale = length;
            Component.name = Component.name + num;
            num++;
            currentIndex[key] = 0;
            pools[key].Add(Component);
            return Component;
        }
    }

    public void Delete(int key, int count)
    {
        pools[key][count].SetActive(false);
        currentIndex[key] = count; 
        //pools[key].RemoveAt(num);
    }

    //public void CreateComponent(List<GameObject> chiefPool, int key, GameObject prefab, Vector3 position, Quaternion angleManager)
    //{
    //    if (currentIndex[key] < pools[key].Count)
    //        Create(key, prefab, position, angleManager).SetActive(true);
    //    else
    //        chiefPool.Add(Create(key, prefab, position, angleManager));
    //}
}
